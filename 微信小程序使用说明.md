# JSZip 加密功能 - 微信小程序使用说明

## 📦 打包状态

✅ **已成功编译打包**  
- 文件位置：`dist/jszip.min.js`  
- 文件大小：约 98KB（压缩后）  
- 加密功能：已包含 ✓  
- 测试状态：功能验证通过 ✓  

## 🚀 快速开始

### 1. 复制文件到小程序项目

```bash
# 将编译后的文件复制到小程序项目
cp dist/jszip.min.js /path/to/your/miniprogram/utils/
```

### 2. 在小程序中引入

```javascript
// pages/index/index.js
const JSZip = require('../../utils/jszip.min.js');
```

---

## 📖 使用示例

### 一、解压带密码的 ZIP 文件

#### 示例 1：基础解压

```javascript
Page({
  async unzipEncrypted() {
    const fs = wx.getFileSystemManager();
    
    // 读取加密的 ZIP 文件
    fs.readFile({
      filePath: 'path/to/encrypted.zip',
      success: async (res) => {
        try {
          // 解压（提供密码）
          const zip = await JSZip.loadAsync(res.data, {
            password: 'yourPassword'
          });
          
          // 获取文件列表
          const fileNames = Object.keys(zip.files);
          console.log('文件列表:', fileNames);
          
          // 读取文件内容
          const content = await zip.file('secret.txt').async('string');
          console.log('文件内容:', content);
          
          wx.showToast({ title: '解压成功', icon: 'success' });
        } catch (err) {
          console.error('解压失败:', err);
          wx.showModal({
            title: '错误',
            content: err.message.includes('password') 
              ? '密码错误' 
              : '解压失败',
            showCancel: false
          });
        }
      },
      fail: (err) => {
        console.error('读取文件失败:', err);
      }
    });
  }
});
```

#### 示例 2：解压所有文件并保存

```javascript
async unzipAllFiles() {
  const fs = wx.getFileSystemManager();
  
  try {
    // 读取 ZIP 文件
    const zipData = fs.readFileSync('encrypted.zip');
    
    // 加载 ZIP（提供密码）
    const zip = await JSZip.loadAsync(zipData, {
      password: 'myPassword123'
    });
    
    // 遍历所有文件
    for (let filename in zip.files) {
      const file = zip.files[filename];
      
      if (!file.dir) {
        // 读取文件内容
        const content = await file.async('uint8array');
        
        // 保存到本地
        const savePath = `${wx.env.USER_DATA_PATH}/${filename}`;
        fs.writeFileSync(savePath, content.buffer);
        
        console.log(`已保存: ${filename}`);
      }
    }
    
    wx.showToast({ title: '解压完成', icon: 'success' });
  } catch (err) {
    wx.showModal({
      title: '错误',
      content: err.message,
      showCancel: false
    });
  }
}
```

#### 示例 3：显示解压进度

```javascript
async unzipWithProgress() {
  const fs = wx.getFileSystemManager();
  const zipData = fs.readFileSync('encrypted.zip');
  
  try {
    const zip = await JSZip.loadAsync(zipData, {
      password: 'password'
    });
    
    // 读取文件时显示进度
    const content = await zip.file('large.txt').async('string', (metadata) => {
      const percent = metadata.percent.toFixed(2);
      console.log(`解压进度: ${percent}%`);
      
      // 更新 UI
      this.setData({
        progress: percent
      });
    });
    
    console.log('解压完成');
  } catch (err) {
    console.error('解压失败:', err);
  }
}
```

### 二、创建带密码的 ZIP 文件

#### 示例 1：基础创建

```javascript
async createEncryptedZip() {
  const zip = new JSZip();
  
  // 添加文件
  zip.file('secret.txt', '这是机密信息');
  zip.file('data.json', JSON.stringify({
    secret: 'value',
    timestamp: Date.now()
  }));
  
  try {
    // 生成加密 ZIP（使用 uint8array，小程序兼容）
    const content = await zip.generateAsync({
      type: 'uint8array',
      compression: 'DEFLATE',
      password: 'myPassword',
      encryptionMethod: 'traditional'
    });
    
    // 保存到小程序文件系统
    const fs = wx.getFileSystemManager();
    const filePath = `${wx.env.USER_DATA_PATH}/encrypted.zip`;
    
    fs.writeFile({
      filePath: filePath,
      data: content.buffer,
      success: () => {
        console.log('加密 ZIP 创建成功:', filePath);
        wx.showToast({ title: '创建成功', icon: 'success' });
      },
      fail: (err) => {
        console.error('保存失败:', err);
        wx.showToast({ title: '保存失败', icon: 'none' });
      }
    });
  } catch (err) {
    console.error('创建失败:', err);
    wx.showToast({ title: err.message, icon: 'none' });
  }
}
```

#### 示例 2：从网络下载并加密

```javascript
async downloadAndEncrypt() {
  // 下载文件
  const res = await new Promise((resolve, reject) => {
    wx.downloadFile({
      url: 'https://example.com/data.json',
      success: resolve,
      fail: reject
    });
  });
  
  // 读取下载的文件
  const fs = wx.getFileSystemManager();
  const data = fs.readFileSync(res.tempFilePath);
  
  // 创建加密 ZIP
  const zip = new JSZip();
  zip.file('data.json', data);
  
  const encrypted = await zip.generateAsync({
    type: 'uint8array',
    password: 'userPassword',
    encryptionMethod: 'traditional'
  });
  
  // 保存加密 ZIP
  const savePath = `${wx.env.USER_DATA_PATH}/encrypted_data.zip`;
  fs.writeFileSync(savePath, encrypted.buffer);
  
  wx.showToast({ title: '加密完成', icon: 'success' });
}
```

#### 示例 3：批量文件加密

```javascript
async encryptMultipleFiles() {
  const zip = new JSZip();
  
  // 添加多个文件
  const files = [
    { name: 'file1.txt', content: '内容1' },
    { name: 'file2.txt', content: '内容2' },
    { name: 'folder/file3.txt', content: '内容3' }
  ];
  
  files.forEach(file => {
    zip.file(file.name, file.content);
  });
  
  // 生成加密 ZIP
  const encrypted = await zip.generateAsync({
    type: 'uint8array',
    password: 'batchPassword',
    compression: 'DEFLATE'
  });
  
  // 保存
  const fs = wx.getFileSystemManager();
  fs.writeFileSync(
    `${wx.env.USER_DATA_PATH}/batch_encrypted.zip`,
    encrypted.buffer
  );
  
  wx.showToast({ title: '批量加密完成', icon: 'success' });
}
```

### 三、完整示例页面

```javascript
// pages/zip-demo/index.js
const JSZip = require('../../utils/jszip.min.js');

Page({
  data: {
    password: '',
    fileList: [],
    loading: false,
    progress: 0
  },
  
  // 输入密码
  onPasswordInput(e) {
    this.setData({
      password: e.detail.value
    });
  },
  
  // 选择 ZIP 文件
  chooseZip() {
    wx.chooseMessageFile({
      count: 1,
      type: 'file',
      success: (res) => {
        const file = res.tempFiles[0];
        this.unzipFile(file.path);
      }
    });
  },
  
  // 解压文件
  async unzipFile(filePath) {
    if (!this.data.password) {
      wx.showToast({ title: '请输入密码', icon: 'none' });
      return;
    }
    
    this.setData({ loading: true, progress: 0 });
    
    try {
      const fs = wx.getFileSystemManager();
      const data = fs.readFileSync(filePath);
      
      // 加载 ZIP
      const zip = await JSZip.loadAsync(data, {
        password: this.data.password
      });
      
      // 获取文件列表
      const fileList = [];
      for (let filename in zip.files) {
        if (!zip.files[filename].dir) {
          const file = zip.files[filename];
          fileList.push({
            name: filename,
            size: file._data?.uncompressedSize || 0
          });
        }
      }
      
      this.setData({ fileList, loading: false });
      wx.showToast({ title: '加载成功', icon: 'success' });
      
    } catch (err) {
      this.setData({ loading: false });
      wx.showModal({
        title: '错误',
        content: err.message.includes('password') 
          ? '密码错误或文件已加密' 
          : '文件格式错误',
        showCancel: false
      });
    }
  },
  
  // 读取文件内容
  async readFile(filename) {
    try {
      const fs = wx.getFileSystemManager();
      const zipData = fs.readFileSync('path/to/encrypted.zip');
      
      const zip = await JSZip.loadAsync(zipData, {
        password: this.data.password
      });
      
      const content = await zip.file(filename).async('string', (metadata) => {
        this.setData({
          progress: metadata.percent.toFixed(2)
        });
      });
      
      wx.showModal({
        title: filename,
        content: content.substring(0, 500),
        showCancel: false
      });
      
    } catch (err) {
      wx.showToast({ title: err.message, icon: 'none' });
    }
  },
  
  // 创建加密 ZIP
  async createZip() {
    if (!this.data.password) {
      wx.showToast({ title: '请输入密码', icon: 'none' });
      return;
    }
    
    this.setData({ loading: true });
    
    const zip = new JSZip();
    zip.file('demo.txt', '这是演示文件');
    zip.file('info.json', JSON.stringify({
      created: new Date().toISOString(),
      app: 'WeChat MiniProgram'
    }));
    
    try {
      const content = await zip.generateAsync({
        type: 'uint8array',
        password: this.data.password,
        encryptionMethod: 'traditional'
      });
      
      const fs = wx.getFileSystemManager();
      const filePath = `${wx.env.USER_DATA_PATH}/demo.zip`;
      
      fs.writeFile({
        filePath: filePath,
        data: content.buffer,
        success: () => {
          this.setData({ loading: false });
          wx.showModal({
            title: '成功',
            content: `文件已保存: ${filePath}`,
            showCancel: false
          });
        },
        fail: (err) => {
          this.setData({ loading: false });
          wx.showToast({ title: '保存失败', icon: 'none' });
        }
      });
      
    } catch (err) {
      this.setData({ loading: false });
      wx.showToast({ title: err.message, icon: 'none' });
    }
  }
});
```

```xml
<!-- pages/zip-demo/index.wxml -->
<view class="container">
  <view class="section">
    <text class="title">密码</text>
    <input 
      class="input" 
      type="text" 
      password="{{true}}"
      placeholder="请输入 ZIP 密码"
      bindinput="onPasswordInput"
      value="{{password}}"
    />
  </view>
  
  <view class="section">
    <button bindtap="chooseZip" disabled="{{loading}}">
      选择并解压 ZIP 文件
    </button>
  </view>
  
  <view class="section">
    <button bindtap="createZip" disabled="{{loading}}">
      创建加密 ZIP
    </button>
  </view>
  
  <view class="section" wx:if="{{fileList.length > 0}}">
    <text class="title">文件列表</text>
    <view wx:for="{{fileList}}" wx:key="name" class="file-item">
      <text>{{item.name}}</text>
      <text class="size">({{item.size}} bytes)</text>
      <button size="mini" bindtap="readFile" data-filename="{{item.name}}">
        查看
      </button>
    </view>
  </view>
  
  <view wx:if="{{loading}}" class="loading">
    <text>处理中... {{progress}}%</text>
  </view>
</view>
```

---

## ⚠️ 重要注意事项

### 1. 安全性警告

**ZIP 2.0 传统加密不安全！**

- ⚠️ 仅用于基础数据保护
- ⚠️ 不适合敏感数据（如支付信息、身份证等）
- ⚠️ 密码长度建议 ≥ 8 位，包含字母和数字
- ⚠️ 不要将密码硬编码在代码中

### 2. 性能建议

- 大文件（>5MB）加密/解密可能较慢
- 建议显示 loading 提示
- 可以使用进度回调显示进度
- 考虑使用分包加载，避免影响主包大小

### 3. 兼容性

- ✅ 支持微信小程序基础库 2.0+
- ✅ 创建的加密 ZIP 可用 WinRAR/7-Zip 等工具打开
- ✅ 可以解压其他工具创建的 ZIP 2.0 加密文件
- ✅ 使用 `uint8array` 类型，完全兼容小程序

### 4. 文件大小

- `jszip.min.js` 约 98KB（压缩后）
- 加密功能增加约 15-20KB
- 建议放在分包中，避免影响主包大小

---

## 🔧 常见问题

### Q1: 解压时提示"密码错误"

**可能原因**：
- 密码输入错误
- ZIP 文件使用了其他加密方式（如 AES，当前不支持）
- 文件已损坏

**解决方法**：
- 确认密码正确
- 检查 ZIP 文件是否使用 ZIP 2.0 传统加密
- 尝试用其他工具（如 WinRAR）验证文件

### Q2: 创建 ZIP 后无法用其他工具打开

**可能原因**：
- 使用了不兼容的选项
- 文件损坏

**解决方法**：
```javascript
// 使用标准选项
zip.generateAsync({
  type: 'uint8array',
  compression: 'DEFLATE',  // 使用标准压缩
  password: 'password',
  encryptionMethod: 'traditional'  // 使用传统加密
});
```

### Q3: 大文件处理慢

**解决方法**：
- 显示进度提示
- 考虑分块处理
- 使用 Web Worker（如果小程序支持）

### Q4: 内存占用高

**解决方法**：
- 避免一次性加载大文件
- 使用流式处理
- 及时释放不需要的数据

---

## 📚 API 参考

### JSZip.loadAsync(data, options)

加载 ZIP 文件（支持加密）

**参数**：
- `data`: ArrayBuffer | Uint8Array | Buffer - ZIP 文件数据
- `options.password`: string - 密码（加密文件必需）

**返回**：Promise<JSZip>

### zip.generateAsync(options)

生成 ZIP 文件（支持加密）

**参数**：
- `options.type`: 'uint8array' | 'blob' | 'nodebuffer' - 输出类型
- `options.password`: string - 密码
- `options.encryptionMethod`: 'traditional' - 加密方法
- `options.compression`: 'DEFLATE' | 'STORE' - 压缩方法

**返回**：Promise<Uint8Array | Blob | Buffer>

---

## ✅ 验证清单

使用前请确认：

- [ ] 已复制 `dist/jszip.min.js` 到小程序项目
- [ ] 已在小程序中正确引入
- [ ] 使用 `uint8array` 类型（小程序兼容）
- [ ] 密码长度 ≥ 8 位
- [ ] 已了解安全限制
- [ ] 已测试基本功能

---

## 🎉 开始使用

现在您可以：

1. ✅ 解压带密码的 ZIP 文件
2. ✅ 创建带密码的 ZIP 文件
3. ✅ 在微信小程序中完整使用

**祝使用愉快！**

